# PostgreSQL Complete Course
## 8-Hour Training Program

---

# Module 1: Database Fundamentals
## Duration: 45 minutes

---

## What is a Database?

A database is an organized collection of structured data stored electronically.

**Key Concepts:**
- Data persistence beyond application runtime
- Structured storage with relationships
- Efficient retrieval and manipulation
- Concurrent access by multiple users

**Real-world examples:** Banking systems, e-commerce catalogs, social media platforms

---

## Types of Databases

| Type | Description | Examples |
|------|-------------|----------|
| Relational (RDBMS) | Tables with rows and columns | PostgreSQL, MySQL, Oracle |
| Document | JSON/BSON documents | MongoDB, CouchDB |
| Key-Value | Simple key-value pairs | Redis, DynamoDB |
| Graph | Nodes and relationships | Neo4j, Amazon Neptune |
| Time-Series | Optimized for time-stamped data | InfluxDB, TimescaleDB |

---

## Why PostgreSQL?

PostgreSQL is the world's most advanced open-source relational database.

**Advantages:**
- **Open Source** ‚Äì Free to use, modify, and distribute
- **ACID Compliant** ‚Äì Reliable transactions
- **Extensible** ‚Äì Custom functions, data types, operators
- **Standards Compliant** ‚Äì Follows SQL standards closely
- **Advanced Features** ‚Äì JSON, full-text search, GIS support
- **Active Community** ‚Äì Regular updates and strong support

---

## Relational Database Concepts

**Tables (Relations)**
- Core structure for storing data
- Organized into rows (records) and columns (fields)

**Schema**
- Logical container for database objects
- Helps organize tables, views, functions

**Primary Key**
- Unique identifier for each row
- Cannot be NULL

**Foreign Key**
- Links tables together
- Enforces referential integrity

---

## The ACID Properties

| Property | Meaning | Example |
|----------|---------|---------|
| **Atomicity** | All or nothing | Transfer completes fully or not at all |
| **Consistency** | Valid state transitions | Account balance never negative |
| **Isolation** | Concurrent transactions don't interfere | Two users don't overwrite each other |
| **Durability** | Committed data persists | Data survives power failure |

---

## SQL Overview

**SQL = Structured Query Language**

Four main categories:

- **DDL** (Data Definition Language): CREATE, ALTER, DROP
- **DML** (Data Manipulation Language): SELECT, INSERT, UPDATE, DELETE
- **DCL** (Data Control Language): GRANT, REVOKE
- **TCL** (Transaction Control Language): BEGIN, COMMIT, ROLLBACK

---

# Module 2: PostgreSQL Installation & Setup
## Duration: 30 minutes

---

## Installing PostgreSQL

**Linux (Ubuntu/Debian):**
```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
```

**macOS (Homebrew):**
```bash
brew install postgresql@16
brew services start postgresql@16
```

**Windows:**
Download installer from postgresql.org

---

## PostgreSQL Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Client Applications           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Postmaster Process            ‚îÇ
‚îÇ         (Main Server Process)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚ñº              ‚ñº              ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇBackend ‚îÇ   ‚îÇBackend ‚îÇ    ‚îÇBackend ‚îÇ
‚îÇProcess ‚îÇ   ‚îÇProcess ‚îÇ    ‚îÇProcess ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Key Configuration Files

| File | Purpose |
|------|---------|
| `postgresql.conf` | Main server configuration |
| `pg_hba.conf` | Client authentication rules |
| `pg_ident.conf` | User name mapping |

**Location (Linux):** `/etc/postgresql/{version}/main/`

---

## Connecting to PostgreSQL

**Using psql (command line):**
```bash
# Connect as postgres user
sudo -u postgres psql

# Connect to specific database
psql -h localhost -U username -d database_name
```

**Connection string format:**
```
postgresql://user:password@host:port/database
```

---

## psql Essential Commands

| Command | Description |
|---------|-------------|
| `\l` | List all databases |
| `\c dbname` | Connect to database |
| `\dt` | List tables |
| `\d tablename` | Describe table structure |
| `\du` | List users/roles |
| `\q` | Quit psql |
| `\?` | Help for psql commands |
| `\h` | Help for SQL commands |

---

## Creating Your First Database

```sql
-- Create a new database
CREATE DATABASE myapp;

-- Connect to it
\c myapp

-- Create a schema (optional, uses 'public' by default)
CREATE SCHEMA app;

-- Set search path
SET search_path TO app, public;
```

---

# Module 3: Data Types
## Duration: 45 minutes

---

## Numeric Types

| Type | Storage | Range |
|------|---------|-------|
| `SMALLINT` | 2 bytes | -32,768 to 32,767 |
| `INTEGER` | 4 bytes | -2.1B to 2.1B |
| `BIGINT` | 8 bytes | ¬±9.2 quintillion |
| `DECIMAL(p,s)` | variable | exact precision |
| `NUMERIC(p,s)` | variable | exact precision |
| `REAL` | 4 bytes | 6 decimal digits |
| `DOUBLE PRECISION` | 8 bytes | 15 decimal digits |
| `SERIAL` | 4 bytes | auto-increment |

---

## Character Types

| Type | Description |
|------|-------------|
| `CHAR(n)` | Fixed-length, padded with spaces |
| `VARCHAR(n)` | Variable-length with limit |
| `TEXT` | Variable unlimited length |

**Best Practice:** Use `TEXT` for most cases; PostgreSQL optimizes it well

```sql
CREATE TABLE users (
    username VARCHAR(50),
    bio TEXT
);
```

---

## Date and Time Types

| Type | Description | Example |
|------|-------------|---------|
| `DATE` | Date only | '2024-01-15' |
| `TIME` | Time only | '14:30:00' |
| `TIMESTAMP` | Date and time | '2024-01-15 14:30:00' |
| `TIMESTAMPTZ` | With timezone | '2024-01-15 14:30:00+07' |
| `INTERVAL` | Time span | '2 hours 30 minutes' |

**Best Practice:** Always use `TIMESTAMPTZ` for timestamps

---

## Boolean Type

```sql
-- Valid boolean values
TRUE, FALSE, NULL
't', 'f'
'yes', 'no'
'on', 'off'
'1', '0'

-- Example
CREATE TABLE tasks (
    id SERIAL PRIMARY KEY,
    title TEXT,
    completed BOOLEAN DEFAULT FALSE
);
```

---

## UUID Type

**Universally Unique Identifier** ‚Äì 128-bit number

```sql
-- Enable extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Use as primary key
CREATE TABLE orders (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    customer_name TEXT,
    total DECIMAL(10,2)
);

-- Or use built-in function (PostgreSQL 13+)
CREATE TABLE products (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT
);
```

---

## JSON Types

| Type | Description |
|------|-------------|
| `JSON` | Stores as text, parsed on each access |
| `JSONB` | Binary format, indexed, faster queries |

```sql
CREATE TABLE events (
    id SERIAL PRIMARY KEY,
    data JSONB
);

INSERT INTO events (data) VALUES 
    ('{"type": "click", "page": "/home", "timestamp": "2024-01-15"}');

-- Query JSON
SELECT data->>'type' AS event_type FROM events;
SELECT data->'page' FROM events;  -- Returns JSON
SELECT data->>'page' FROM events; -- Returns text
```

---

## Array Types

```sql
-- Array column
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    tags TEXT[]
);

INSERT INTO products (name, tags) 
VALUES ('Laptop', ARRAY['electronics', 'computers', 'sale']);

-- Query arrays
SELECT * FROM products WHERE 'sale' = ANY(tags);
SELECT * FROM products WHERE tags @> ARRAY['electronics'];

-- Array functions
SELECT array_length(tags, 1) FROM products;
SELECT unnest(tags) FROM products;
```

---

## Special Types

| Type | Use Case |
|------|----------|
| `BYTEA` | Binary data (images, files) |
| `INET` | IPv4 or IPv6 addresses |
| `CIDR` | Network addresses |
| `MACADDR` | MAC addresses |
| `MONEY` | Currency (locale-aware) |
| `POINT, LINE, POLYGON` | Geometric data |
| `TSVECTOR, TSQUERY` | Full-text search |

---

# Module 4: Creating Tables & Constraints
## Duration: 60 minutes

---

## CREATE TABLE Syntax

```sql
CREATE TABLE table_name (
    column1 data_type [constraints],
    column2 data_type [constraints],
    ...
    [table_constraints]
);
```

**Example:**
```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    hire_date DATE DEFAULT CURRENT_DATE,
    salary DECIMAL(10,2) CHECK (salary > 0)
);
```

---

## PRIMARY KEY Constraint

Uniquely identifies each row in a table.

```sql
-- Single column (inline)
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username TEXT
);

-- Single column (table-level)
CREATE TABLE users (
    id SERIAL,
    username TEXT,
    PRIMARY KEY (id)
);

-- Composite primary key
CREATE TABLE order_items (
    order_id INTEGER,
    product_id INTEGER,
    quantity INTEGER,
    PRIMARY KEY (order_id, product_id)
);
```

---

## FOREIGN KEY Constraint

Creates relationships between tables.

```sql
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);

CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INTEGER REFERENCES departments(id)
);

-- With explicit constraint name and actions
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department_id INTEGER,
    CONSTRAINT fk_department 
        FOREIGN KEY (department_id) 
        REFERENCES departments(id)
        ON DELETE SET NULL
        ON UPDATE CASCADE
);
```

---

## Foreign Key Actions

| Action | On DELETE | On UPDATE |
|--------|-----------|-----------|
| `CASCADE` | Delete child rows | Update child FK values |
| `SET NULL` | Set FK to NULL | Set FK to NULL |
| `SET DEFAULT` | Set FK to default | Set FK to default |
| `RESTRICT` | Prevent deletion | Prevent update |
| `NO ACTION` | Same as RESTRICT (default) | Same as RESTRICT |

---

## NOT NULL & DEFAULT

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    
    -- NOT NULL - value required
    name VARCHAR(100) NOT NULL,
    
    -- DEFAULT - value if not provided
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- Both combined
    stock INTEGER NOT NULL DEFAULT 0
);
```

---

## UNIQUE Constraint

Ensures no duplicate values in a column.

```sql
-- Single column
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE
);

-- Multiple columns (composite unique)
CREATE TABLE user_roles (
    user_id INTEGER,
    role_id INTEGER,
    UNIQUE (user_id, role_id)
);

-- Named constraint
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    sku VARCHAR(50),
    CONSTRAINT unique_sku UNIQUE (sku)
);
```

---

## CHECK Constraint

Validates data against a condition.

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    price DECIMAL(10,2) CHECK (price >= 0),
    discount_percent INTEGER CHECK (discount_percent BETWEEN 0 AND 100),
    
    -- Named constraint
    CONSTRAINT valid_quantity CHECK (quantity >= 0),
    
    -- Multi-column check
    CONSTRAINT valid_dates CHECK (end_date > start_date)
);
```

---

## Modifying Tables (ALTER TABLE)

```sql
-- Add column
ALTER TABLE employees ADD COLUMN phone VARCHAR(20);

-- Drop column
ALTER TABLE employees DROP COLUMN phone;

-- Rename column
ALTER TABLE employees RENAME COLUMN name TO full_name;

-- Change data type
ALTER TABLE employees ALTER COLUMN salary TYPE NUMERIC(12,2);

-- Add constraint
ALTER TABLE employees ADD CONSTRAINT salary_positive CHECK (salary > 0);

-- Drop constraint
ALTER TABLE employees DROP CONSTRAINT salary_positive;

-- Rename table
ALTER TABLE employees RENAME TO staff;
```

---

## Dropping Tables

```sql
-- Basic drop (fails if table doesn't exist)
DROP TABLE table_name;

-- Safe drop
DROP TABLE IF EXISTS table_name;

-- Drop with dependencies (cascades to dependent objects)
DROP TABLE table_name CASCADE;

-- Drop multiple tables
DROP TABLE table1, table2, table3;
```

---

# Module 5: Basic CRUD Operations
## Duration: 60 minutes

---

## INSERT - Adding Data

```sql
-- Insert single row
INSERT INTO employees (first_name, last_name, email)
VALUES ('John', 'Doe', 'john@example.com');

-- Insert multiple rows
INSERT INTO employees (first_name, last_name, email)
VALUES 
    ('Jane', 'Smith', 'jane@example.com'),
    ('Bob', 'Wilson', 'bob@example.com'),
    ('Alice', 'Brown', 'alice@example.com');

-- Insert with RETURNING (get inserted data back)
INSERT INTO employees (first_name, last_name, email)
VALUES ('Mike', 'Johnson', 'mike@example.com')
RETURNING id, first_name, last_name;
```

---

## INSERT - Advanced

```sql
-- Insert from SELECT
INSERT INTO employee_archive (id, name, email)
SELECT id, first_name || ' ' || last_name, email
FROM employees
WHERE status = 'inactive';

-- Insert with DEFAULT values
INSERT INTO products (name) VALUES ('Widget');
-- Other columns get their DEFAULT values

-- Upsert (INSERT or UPDATE on conflict)
INSERT INTO products (sku, name, price)
VALUES ('ABC123', 'Widget', 9.99)
ON CONFLICT (sku) 
DO UPDATE SET price = EXCLUDED.price, name = EXCLUDED.name;
```

---

## SELECT - Basic Queries

```sql
-- Select all columns
SELECT * FROM employees;

-- Select specific columns
SELECT first_name, last_name, email FROM employees;

-- Column aliases
SELECT 
    first_name AS "First Name",
    last_name AS "Last Name",
    salary * 12 AS annual_salary
FROM employees;

-- Distinct values
SELECT DISTINCT department_id FROM employees;

-- Limit results
SELECT * FROM employees LIMIT 10;
SELECT * FROM employees LIMIT 10 OFFSET 20;
```

---

## WHERE Clause - Filtering

```sql
-- Comparison operators
SELECT * FROM products WHERE price > 100;
SELECT * FROM products WHERE price >= 100;
SELECT * FROM products WHERE price < 100;
SELECT * FROM products WHERE price <= 100;
SELECT * FROM products WHERE price = 100;
SELECT * FROM products WHERE price <> 100;  -- not equal
SELECT * FROM products WHERE price != 100;  -- not equal

-- Multiple conditions
SELECT * FROM products WHERE price > 50 AND stock > 0;
SELECT * FROM products WHERE category = 'Electronics' OR category = 'Books';
SELECT * FROM products WHERE NOT (price > 100);
```

---

## WHERE Clause - Advanced Operators

```sql
-- IN operator
SELECT * FROM products WHERE category IN ('Electronics', 'Books', 'Toys');

-- BETWEEN operator
SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';

-- LIKE operator (pattern matching)
SELECT * FROM products WHERE name LIKE 'A%';      -- starts with A
SELECT * FROM products WHERE name LIKE '%phone%'; -- contains phone
SELECT * FROM products WHERE name LIKE '_____';   -- exactly 5 characters

-- ILIKE (case-insensitive)
SELECT * FROM products WHERE name ILIKE '%phone%';

-- NULL checks
SELECT * FROM employees WHERE manager_id IS NULL;
SELECT * FROM employees WHERE manager_id IS NOT NULL;
```

---

## ORDER BY - Sorting Results

```sql
-- Ascending order (default)
SELECT * FROM products ORDER BY name;
SELECT * FROM products ORDER BY name ASC;

-- Descending order
SELECT * FROM products ORDER BY price DESC;

-- Multiple columns
SELECT * FROM employees 
ORDER BY department_id ASC, salary DESC;

-- Order by expression
SELECT * FROM products ORDER BY price * (1 - discount/100);

-- NULLS FIRST / NULLS LAST
SELECT * FROM employees ORDER BY manager_id NULLS FIRST;
```

---

## UPDATE - Modifying Data

```sql
-- Update single column
UPDATE employees SET salary = 50000 WHERE id = 1;

-- Update multiple columns
UPDATE employees 
SET salary = 55000, department_id = 3
WHERE id = 1;

-- Update with expression
UPDATE products SET price = price * 1.1;  -- 10% increase

-- Update with RETURNING
UPDATE employees 
SET salary = salary * 1.05
WHERE performance_rating >= 4
RETURNING id, first_name, salary;

-- Update from another table
UPDATE products p
SET stock = i.quantity
FROM inventory i
WHERE p.sku = i.sku;
```

---

## DELETE - Removing Data

```sql
-- Delete specific rows
DELETE FROM employees WHERE id = 1;

-- Delete with condition
DELETE FROM products WHERE stock = 0 AND discontinued = true;

-- Delete all rows (careful!)
DELETE FROM logs;

-- Delete with RETURNING
DELETE FROM employees 
WHERE hire_date < '2020-01-01'
RETURNING *;

-- TRUNCATE - faster for deleting all rows
TRUNCATE TABLE logs;
TRUNCATE TABLE logs RESTART IDENTITY;  -- Reset serial sequences
```

---

# Module 6: Joins & Relationships
## Duration: 60 minutes

---

## Understanding Joins

Joins combine rows from two or more tables based on a related column.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  employees  ‚îÇ         ‚îÇ departments ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§         ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ id          ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ id          ‚îÇ
‚îÇ name        ‚îÇ         ‚îÇ name        ‚îÇ
‚îÇ dept_id     ‚îÇ         ‚îÇ location    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## INNER JOIN

Returns only rows with matching values in both tables.

```sql
SELECT 
    e.first_name,
    e.last_name,
    d.name AS department
FROM employees e
INNER JOIN departments d ON e.department_id = d.id;
```

```
employees          departments         Result
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ id ‚îÇ name  ‚îÇ    ‚îÇ id ‚îÇ name    ‚îÇ    ‚îÇ name  ‚îÇ dept    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1  ‚îÇ John  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ 1  ‚îÇ Sales   ‚îÇ    ‚îÇ John  ‚îÇ Sales   ‚îÇ
‚îÇ 2  ‚îÇ Jane  ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ 2  ‚îÇ IT      ‚îÇ    ‚îÇ Jane  ‚îÇ IT      ‚îÇ
‚îÇ 3  ‚îÇ Bob   ‚îÇ X  ‚îÇ 3  ‚îÇ HR      ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 (dept_id NULL)
```

---

## LEFT JOIN (LEFT OUTER JOIN)

Returns all rows from the left table, plus matching rows from the right.

```sql
SELECT 
    e.first_name,
    e.last_name,
    d.name AS department
FROM employees e
LEFT JOIN departments d ON e.department_id = d.id;
```

```
Result:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ name  ‚îÇ dept    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ John  ‚îÇ Sales   ‚îÇ
‚îÇ Jane  ‚îÇ IT      ‚îÇ
‚îÇ Bob   ‚îÇ NULL    ‚îÇ  ‚óÄ‚îÄ‚îÄ Included even without match
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## RIGHT JOIN (RIGHT OUTER JOIN)

Returns all rows from the right table, plus matching rows from the left.

```sql
SELECT 
    e.first_name,
    d.name AS department
FROM employees e
RIGHT JOIN departments d ON e.department_id = d.id;
```

```
Result:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ name  ‚îÇ dept    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ John  ‚îÇ Sales   ‚îÇ
‚îÇ Jane  ‚îÇ IT      ‚îÇ
‚îÇ NULL  ‚îÇ HR      ‚îÇ  ‚óÄ‚îÄ‚îÄ Included even without match
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## FULL OUTER JOIN

Returns all rows when there's a match in either table.

```sql
SELECT 
    e.first_name,
    d.name AS department
FROM employees e
FULL OUTER JOIN departments d ON e.department_id = d.id;
```

```
Result:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ name  ‚îÇ dept    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ John  ‚îÇ Sales   ‚îÇ
‚îÇ Jane  ‚îÇ IT      ‚îÇ
‚îÇ Bob   ‚îÇ NULL    ‚îÇ  ‚óÄ‚îÄ‚îÄ No matching department
‚îÇ NULL  ‚îÇ HR      ‚îÇ  ‚óÄ‚îÄ‚îÄ No matching employee
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## CROSS JOIN

Returns the Cartesian product (all combinations).

```sql
SELECT 
    p.name AS product,
    c.name AS color
FROM products p
CROSS JOIN colors c;
```

```
products √ó colors = result
  (3)    √ó   (2)   =  (6)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ product ‚îÇ color ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Shirt   ‚îÇ Red   ‚îÇ
‚îÇ Shirt   ‚îÇ Blue  ‚îÇ
‚îÇ Pants   ‚îÇ Red   ‚îÇ
‚îÇ Pants   ‚îÇ Blue  ‚îÇ
‚îÇ Hat     ‚îÇ Red   ‚îÇ
‚îÇ Hat     ‚îÇ Blue  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Self Join

A table joined with itself.

```sql
-- Find employees and their managers
SELECT 
    e.first_name AS employee,
    m.first_name AS manager
FROM employees e
LEFT JOIN employees m ON e.manager_id = m.id;

-- Find employees in the same department
SELECT 
    e1.first_name AS employee1,
    e2.first_name AS employee2,
    e1.department_id
FROM employees e1
JOIN employees e2 ON e1.department_id = e2.department_id
WHERE e1.id < e2.id;  -- Avoid duplicates
```

---

## Multiple Table Joins

```sql
SELECT 
    o.id AS order_id,
    c.name AS customer,
    p.name AS product,
    oi.quantity,
    oi.unit_price
FROM orders o
JOIN customers c ON o.customer_id = c.id
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
WHERE o.order_date >= '2024-01-01';
```

---

## Join Best Practices

**1. Use explicit JOIN syntax (not WHERE clause joins)**
```sql
-- Good ‚úì
SELECT * FROM a JOIN b ON a.id = b.a_id;

-- Avoid ‚úó
SELECT * FROM a, b WHERE a.id = b.a_id;
```

**2. Always use table aliases**
```sql
SELECT e.name, d.name FROM employees e JOIN departments d ON e.dept_id = d.id;
```

**3. Join on indexed columns for performance**

**4. Consider join order for complex queries**

---

# Module 7: Aggregate Functions & GROUP BY
## Duration: 45 minutes

---

## Aggregate Functions

| Function | Description |
|----------|-------------|
| `COUNT(*)` | Count all rows |
| `COUNT(column)` | Count non-NULL values |
| `COUNT(DISTINCT column)` | Count unique values |
| `SUM(column)` | Total of values |
| `AVG(column)` | Average of values |
| `MIN(column)` | Minimum value |
| `MAX(column)` | Maximum value |
| `ARRAY_AGG(column)` | Collect into array |
| `STRING_AGG(column, delimiter)` | Concatenate strings |

---

## Basic Aggregation Examples

```sql
-- Count all employees
SELECT COUNT(*) AS total_employees FROM employees;

-- Count employees with email
SELECT COUNT(email) AS employees_with_email FROM employees;

-- Sum of all salaries
SELECT SUM(salary) AS total_payroll FROM employees;

-- Average salary
SELECT AVG(salary) AS average_salary FROM employees;

-- Salary range
SELECT 
    MIN(salary) AS lowest_salary,
    MAX(salary) AS highest_salary
FROM employees;
```

---

## GROUP BY Clause

Groups rows that have the same values.

```sql
-- Count employees per department
SELECT 
    department_id,
    COUNT(*) AS employee_count
FROM employees
GROUP BY department_id;

-- Total sales per product
SELECT 
    product_id,
    SUM(quantity) AS total_sold,
    SUM(quantity * unit_price) AS total_revenue
FROM order_items
GROUP BY product_id;
```

---

## GROUP BY with Joins

```sql
-- Sales by department name
SELECT 
    d.name AS department,
    COUNT(*) AS employee_count,
    SUM(e.salary) AS total_salary,
    ROUND(AVG(e.salary), 2) AS avg_salary
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.name
ORDER BY total_salary DESC;
```

---

## HAVING Clause

Filters groups (like WHERE, but for aggregates).

```sql
-- Departments with more than 5 employees
SELECT 
    department_id,
    COUNT(*) AS employee_count
FROM employees
GROUP BY department_id
HAVING COUNT(*) > 5;

-- Products with total sales over $10,000
SELECT 
    product_id,
    SUM(quantity * unit_price) AS total_sales
FROM order_items
GROUP BY product_id
HAVING SUM(quantity * unit_price) > 10000
ORDER BY total_sales DESC;
```

---

## WHERE vs HAVING

| WHERE | HAVING |
|-------|--------|
| Filters rows | Filters groups |
| Before grouping | After grouping |
| Can't use aggregates | Can use aggregates |

```sql
SELECT 
    department_id,
    AVG(salary) AS avg_salary
FROM employees
WHERE status = 'active'      -- Filter rows first
GROUP BY department_id
HAVING AVG(salary) > 50000;  -- Then filter groups
```

---

## Advanced Aggregation

```sql
-- Multiple grouping columns
SELECT 
    EXTRACT(YEAR FROM order_date) AS year,
    EXTRACT(MONTH FROM order_date) AS month,
    COUNT(*) AS order_count,
    SUM(total) AS revenue
FROM orders
GROUP BY year, month
ORDER BY year, month;

-- String aggregation
SELECT 
    department_id,
    STRING_AGG(first_name, ', ' ORDER BY first_name) AS employees
FROM employees
GROUP BY department_id;

-- Array aggregation
SELECT 
    category,
    ARRAY_AGG(name ORDER BY name) AS products
FROM products
GROUP BY category;
```

---

---

# Module 8: Indexes & Performance
## Duration: 45 minutes

---

## Why Indexes Matter

Without index: Full table scan (O(n))
With index: B-tree lookup (O(log n))

```
Table: 1,000,000 rows
Without index: ~1,000,000 operations
With B-tree index: ~20 operations
```

---

## Creating Indexes

```sql
-- Basic index
CREATE INDEX idx_employees_email ON employees(email);

-- Unique index
CREATE UNIQUE INDEX idx_users_username ON users(username);

-- Multi-column (composite) index
CREATE INDEX idx_orders_customer_date 
ON orders(customer_id, order_date);

-- Partial index (only some rows)
CREATE INDEX idx_orders_pending 
ON orders(status) 
WHERE status = 'pending';

-- Expression index
CREATE INDEX idx_users_lower_email 
ON users(LOWER(email));
```

---

## Index Types

| Type | Use Case |
|------|----------|
| **B-tree** (default) | Equality, range, sorting |
| **Hash** | Equality only |
| **GiST** | Geometric, full-text |
| **GIN** | Arrays, JSON, full-text |
| **BRIN** | Large tables with natural order |

```sql
-- GIN for JSONB
CREATE INDEX idx_events_data ON events USING GIN(data);

-- GIN for arrays
CREATE INDEX idx_products_tags ON products USING GIN(tags);
```

---

## EXPLAIN - Understanding Query Plans

```sql
-- Basic explain
EXPLAIN SELECT * FROM employees WHERE email = 'john@example.com';

-- With execution stats
EXPLAIN ANALYZE SELECT * FROM employees WHERE email = 'john@example.com';

-- Verbose output
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT) 
SELECT * FROM employees WHERE department_id = 1;
```

---

## Reading EXPLAIN Output

```
Seq Scan on employees  (cost=0.00..155.00 rows=5000 width=72)
  Filter: (department_id = 1)

Index Scan using idx_emp_dept on employees (cost=0.29..8.31 rows=1 width=72)
  Index Cond: (department_id = 1)
```

Key metrics:
- **Cost**: Estimated effort (startup..total)
- **Rows**: Estimated row count
- **Width**: Average row size in bytes
- **Actual time**: Real execution time (with ANALYZE)

---

## Scan Types

| Scan Type | Description | When Used |
|-----------|-------------|-----------|
| Seq Scan | Reads entire table | Small tables, no index |
| Index Scan | Uses index + heap | Selective queries |
| Index Only Scan | Uses index only | Query needs only indexed columns |
| Bitmap Scan | Combines multiple indexes | OR conditions |

---

## Index Best Practices

**DO:**
- Index foreign keys
- Index columns in WHERE clauses
- Index columns used in ORDER BY
- Use partial indexes for filtered queries
- Consider covering indexes for read-heavy queries

**DON'T:**
- Index every column
- Index tiny tables
- Create indexes before understanding queries
- Forget indexes slow down writes

---

## Maintaining Indexes

```sql
-- List indexes
SELECT indexname, indexdef 
FROM pg_indexes 
WHERE tablename = 'employees';

-- Check index usage
SELECT 
    indexrelname AS index_name,
    idx_scan AS times_used,
    pg_size_pretty(pg_relation_size(indexrelid)) AS size
FROM pg_stat_user_indexes
WHERE schemaname = 'public';

-- Remove unused index
DROP INDEX idx_unused;

-- Rebuild index
REINDEX INDEX idx_employees_email;
```

---

# Module 10: Transactions & Concurrency
## Duration: 30 minutes

---

## What is a Transaction?

A sequence of operations treated as a single unit of work.

```sql
BEGIN;                                    -- Start transaction

UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

COMMIT;                                   -- Save changes

-- Or if something went wrong
ROLLBACK;                                 -- Undo all changes
```

---

## Transaction Properties (ACID)

```
BEGIN TRANSACTION
‚îú‚îÄ‚îÄ Operation 1 ‚îÄ‚îê
‚îú‚îÄ‚îÄ Operation 2  ‚îú‚îÄ‚îÄ‚îÄ Atomicity: All succeed or all fail
‚îú‚îÄ‚îÄ Operation 3 ‚îÄ‚îò
‚îÇ
‚îú‚îÄ‚îÄ Consistency: Database stays valid
‚îú‚îÄ‚îÄ Isolation: Other transactions don't see partial changes
‚îî‚îÄ‚îÄ Durability: Once committed, data persists
COMMIT
```

---

## SAVEPOINT - Partial Rollback

```sql
BEGIN;

INSERT INTO orders (customer_id, total) VALUES (1, 100);
SAVEPOINT order_created;

INSERT INTO order_items (order_id, product_id) VALUES (1, 1);
-- Oops, wrong product
ROLLBACK TO SAVEPOINT order_created;

INSERT INTO order_items (order_id, product_id) VALUES (1, 2);

COMMIT;  -- Order is saved, with correct item
```

---

## Isolation Levels

| Level | Dirty Read | Non-Repeatable Read | Phantom Read |
|-------|------------|---------------------|--------------|
| Read Uncommitted | Yes | Yes | Yes |
| Read Committed (default) | No | Yes | Yes |
| Repeatable Read | No | No | Yes* |
| Serializable | No | No | No |

*PostgreSQL prevents phantoms in Repeatable Read

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

---

## Common Concurrency Issues

**Lost Update**
```
T1: Read balance = 100
T2: Read balance = 100
T1: Write balance = 150  (100 + 50)
T2: Write balance = 130  (100 + 30)  -- T1's update lost!
```

**Solution: Use SELECT FOR UPDATE**
```sql
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
-- Other transactions must wait
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
COMMIT;
```

---

## Locking

```sql
-- Row-level lock
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;

-- Skip locked rows (useful for job queues)
SELECT * FROM tasks WHERE status = 'pending' 
FOR UPDATE SKIP LOCKED LIMIT 1;

-- Advisory locks (application-level)
SELECT pg_advisory_lock(123);
-- Do exclusive work
SELECT pg_advisory_unlock(123);
```

---

# Module 12: Views & Materialized Views
## Duration: 30 minutes

---

## What is a View?

A saved query that acts like a virtual table.

```sql
CREATE VIEW active_employees AS
SELECT id, first_name, last_name, email, department_id
FROM employees
WHERE status = 'active';

-- Use it like a table
SELECT * FROM active_employees WHERE department_id = 1;
```

---

## Benefits of Views

- **Simplicity**: Hide complex queries
- **Security**: Restrict access to specific columns/rows
- **Abstraction**: Change underlying tables without breaking apps
- **Consistency**: Ensure everyone uses the same logic

```sql
-- Security: Hide salary from certain users
CREATE VIEW employee_public AS
SELECT id, first_name, last_name, email, department_id
FROM employees;  -- No salary!

GRANT SELECT ON employee_public TO readonly_user;
```

---

## Updatable Views

Simple views can be updated.

```sql
CREATE VIEW marketing_employees AS
SELECT * FROM employees WHERE department_id = 3;

-- This works if the view is simple enough
INSERT INTO marketing_employees (first_name, last_name, department_id)
VALUES ('New', 'Person', 3);

-- WITH CHECK OPTION prevents violations
CREATE VIEW marketing_employees AS
SELECT * FROM employees WHERE department_id = 3
WITH CHECK OPTION;

-- This would fail (department_id != 3)
INSERT INTO marketing_employees (first_name, last_name, department_id)
VALUES ('New', 'Person', 5);  -- Error!
```

---

## Materialized Views

Stores query results physically. Great for expensive queries.

```sql
-- Create materialized view
CREATE MATERIALIZED VIEW monthly_sales_summary AS
SELECT 
    DATE_TRUNC('month', order_date) AS month,
    COUNT(*) AS order_count,
    SUM(total) AS revenue
FROM orders
GROUP BY DATE_TRUNC('month', order_date);

-- Query it (fast!)
SELECT * FROM monthly_sales_summary;

-- Refresh the data
REFRESH MATERIALIZED VIEW monthly_sales_summary;

-- Refresh without locking
REFRESH MATERIALIZED VIEW CONCURRENTLY monthly_sales_summary;
-- Requires a unique index
```

---

## View vs Materialized View

| Aspect | View | Materialized View |
|--------|------|-------------------|
| Storage | None (query only) | Stores data |
| Speed | Runs query each time | Fast (pre-computed) |
| Freshness | Always current | Stale until refreshed |
| Indexes | No | Yes |
| Use case | Simple abstraction | Expensive queries, reports |

---

---

## Useful PostgreSQL Extensions

```sql
-- UUID generation
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Fuzzy string matching
CREATE EXTENSION IF NOT EXISTS pg_trgm;
SELECT * FROM users WHERE name % 'Jon';  -- Finds "John", "Jon"

-- Cryptographic functions
CREATE EXTENSION IF NOT EXISTS pgcrypto;
SELECT crypt('password', gen_salt('bf'));

-- Geographic data
CREATE EXTENSION IF NOT EXISTS postgis;
```

---

---

## Security Best Practices

1. **Use strong passwords** and consider password policies
2. **Limit superuser access** - create specific roles
3. **Use SSL/TLS** for connections
4. **Configure pg_hba.conf** carefully
5. **Regular backups** with tested restores
6. **Keep PostgreSQL updated**
7. **Use Row-Level Security** for multi-tenant apps
8. **Audit sensitive operations**

---

# Best Practices Summary
## Duration: 15 minutes

---

## Naming Conventions

```sql
-- Tables: lowercase, plural, snake_case
CREATE TABLE user_accounts (...);
CREATE TABLE order_items (...);

-- Columns: lowercase, snake_case
first_name, created_at, is_active

-- Indexes: idx_tablename_columns
CREATE INDEX idx_users_email ON users(email);

-- Foreign keys: fk_tablename_reference
CONSTRAINT fk_orders_customer FOREIGN KEY (customer_id)...

-- Primary keys: table_id or just id
id, user_id
```

---

## Query Best Practices

```sql
-- Use explicit column names (not SELECT *)
SELECT id, name, email FROM users;

-- Use table aliases in joins
SELECT u.name, o.total
FROM users u
JOIN orders o ON u.id = o.user_id;

-- Avoid N+1 queries - use joins or batch fetching
-- Bad: Loop with individual queries
-- Good: Single query with JOIN

-- Use EXPLAIN ANALYZE for slow queries
EXPLAIN ANALYZE SELECT ...;

-- Use prepared statements (prevent SQL injection)
PREPARE get_user (int) AS SELECT * FROM users WHERE id = $1;
EXECUTE get_user(1);
```

---

## Schema Design Tips

- **Normalize appropriately** (usually 3NF is good)
- **Use appropriate data types** (don't VARCHAR everything)
- **Add constraints** (NOT NULL, CHECK, FK)
- **Index foreign keys** and frequently queried columns
- **Use TIMESTAMPTZ** for timestamps
- **Consider partitioning** for very large tables
- **Document your schema** with COMMENT

```sql
COMMENT ON TABLE users IS 'Stores user account information';
COMMENT ON COLUMN users.status IS 'active, suspended, or deleted';
```

---

## Common Mistakes to Avoid

‚ùå Using SELECT * in production code
‚ùå Missing indexes on foreign keys
‚ùå Not using transactions for related operations
‚ùå Storing sensitive data in plain text
‚ùå Ignoring database backups
‚ùå Not testing restore procedures
‚ùå Over-indexing or under-indexing
‚ùå Using ORM exclusively without understanding SQL

---

# Quick Reference Card

## Essential Commands

```sql
-- Database operations
CREATE DATABASE name;
DROP DATABASE name;
\c database_name

-- Table operations
CREATE TABLE name (...);
ALTER TABLE name ADD/DROP/ALTER ...;
DROP TABLE name;

-- Data operations
INSERT INTO table VALUES (...);
SELECT columns FROM table WHERE condition;
UPDATE table SET column = value WHERE condition;
DELETE FROM table WHERE condition;

-- Transactions
BEGIN; COMMIT; ROLLBACK;

-- Information
\dt          -- List tables
\d table     -- Describe table
\di          -- List indexes
```

---

# Thank You!

## Course Complete üéâ

**Key takeaways:**
- PostgreSQL is powerful, feature-rich, and free
- Master the fundamentals: tables, queries, joins
- Use indexes wisely for performance
- Understand transactions for data integrity
- Practice regularly with real projects

**Resources:**
- Official Documentation: postgresql.org/docs
- PostgreSQL Wiki: wiki.postgresql.org
- Practice: pgexercises.com

---

# Questions?
